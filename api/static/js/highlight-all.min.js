/*! highlight.js v11.9.0 | BSD3 License | git.io/hljslicense */
(function(window) {
  const hljs = {
    highlightElement: function(block) {
      try {
        if (block && block.textContent) {
          block.classList.add('hljs');
          const code = block.textContent;
          const language = detectLanguage(block);
          const result = hljs.highlight(code, { language: language || 'plaintext', ignoreIllegals: true });
          block.innerHTML = result.value;
          block.classList.add(`language-${result.language}`);
        }
      } catch (e) {
        console.error('Error in syntax highlighting:', e);
      }
    },
    highlight: function(code, options) {
      const language = options.language || 'plaintext';
      const grammar = languages[language] || languages['plaintext'];
      const emitter = new HTMLRenderer({ classPrefix: 'hljs-' });
      const result = compileLanguage(code, grammar, emitter);
      return {
        value: emitter.toHTML(),
        language: language,
        relevance: result.relevance
      };
    },
    highlightAuto: function(code, languageSubset) {
      const languagesToTry = languageSubset || Object.keys(languages);
      let bestResult = { relevance: 0, value: escapeHTML(code), language: 'plaintext' };
      for (const lang of languagesToTry) {
        try {
          const result = hljs.highlight(code, { language: lang });
          if (result.relevance > bestResult.relevance) {
            bestResult = result;
          }
        } catch (e) {}
      }
      return bestResult;
    },
    highlightAll: function() {
      document.querySelectorAll('pre code').forEach(hljs.highlightElement);
    },
    registerLanguage: function(name, language) {
      try {
        languages[name] = language(hljs);
        languages[name].name = name;
      } catch (e) {
        console.error(`Failed to register language '${name}':`, e);
      }
    },
    listLanguages: function() {
      return Object.keys(languages);
    },
    getLanguage: function(name) {
      return languages[name.toLowerCase()];
    }
  };

  const languages = {
    plaintext: { name: 'Plain text', contains: [] },
    javascript: {
      name: 'JavaScript',
      contains: [
        { scope: 'comment', begin: '/\\*', end: '\\*/' },
        { scope: 'comment', begin: '//', end: '$' },
        { scope: 'string', begin: '"', end: '"' },
        { scope: 'string', begin: "'", end: "'" },
        { scope: 'string', begin: '`', end: '`' },
        { scope: 'number', begin: '\\b\\d+(\\.\\d+)?\\b' },
        { scope: 'keyword', begin: '\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|export|extends|finally|for|function|if|import|in|instanceof|let|new|return|super|switch|this|throw|try|typeof|var|void|while|with|yield|async|await)\\b' },
        { scope: 'operator', begin: '[+\\-*/%=&|!><?:]' }
      ]
    },
    python: {
      name: 'Python',
      contains: [
        { scope: 'comment', begin: '#', end: '$' },
        { scope: 'string', begin: '"""', end: '"""' },
        { scope: 'string', begin: '"', end: '"' },
        { scope: 'string', begin: "'", end: "'" },
        { scope: 'number', begin: '\\b\\d+(\\.\\d+)?\\b' },
        { scope: 'keyword', begin: '\\b(and|as|assert|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield|True|False|None)\\b' }
      ]
    },
    css: {
      name: 'CSS',
      contains: [
        { scope: 'comment', begin: '/\\*', end: '\\*/' },
        { scope: 'selector-id', begin: '#[a-zA-Z][a-zA-Z0-9-]*' },
        { scope: 'selector-class', begin: '\\.[a-zA-Z][a-zA-Z0-9-]*' },
        { scope: 'selector-tag', begin: '\\b[a-zA-Z][a-zA-Z0-9-]*(?=\\s*[{,])' },
        { scope: 'property', begin: '\\b[a-zA-Z-]+(?=\\s*:)' },
        { scope: 'string', begin: '"[^"]*"' },
        { scope: 'string', begin: "'[^']*'" },
        { scope: 'number', begin: '\\b\\d+(\\.\\d+)?\\b' },
        { scope: 'unit', begin: '\\b(px|rem|em|vw|vh|%)\\b' }
      ]
    }
  };

  function escapeHTML(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
  }

  function detectLanguage(block) {
    const className = block.className || '';
    const match = /\blang(?:uage)?-([\w-]+)\b/i.exec(className);
    return match ? match[1] : null;
  }

  class HTMLRenderer {
    constructor(options) {
      this.buffer = '';
      this.classPrefix = options.classPrefix || '';
    }
    addText(text) {
      this.buffer += escapeHTML(text);
    }
    openNode(scope) {
      if (scope) {
        this.buffer += `<span class="${this.classPrefix}${scope}">`;
      }
    }
    closeNode(scope) {
      if (scope) {
        this.buffer += '</span>';
      }
    }
    toHTML() {
      return this.buffer;
    }
  }

  function compileLanguage(code, grammar, emitter) {
    let relevance = 0;
    const contains = grammar.contains || [];
    
    // Convert rules to regex objects
    const rules = contains.map(rule => ({
      scope: rule.scope,
      regex: new RegExp(rule.begin, 'g')
    }));

    let result = code;
    let allMatches = [];

    // Find all matches
    rules.forEach(rule => {
      let match;
      rule.regex.lastIndex = 0;
      while ((match = rule.regex.exec(code)) !== null) {
        allMatches.push({
          start: match.index,
          end: match.index + match[0].length,
          text: match[0],
          scope: rule.scope
        });
      }
    });

    // Sort by position
    allMatches.sort((a, b) => a.start - b.start);

    // Remove overlapping matches (keep first one)
    const filteredMatches = [];
    let lastEnd = 0;
    for (const match of allMatches) {
      if (match.start >= lastEnd) {
        filteredMatches.push(match);
        lastEnd = match.end;
        relevance += 1;
      }
    }

    // Apply highlighting from end to start to maintain indices
    filteredMatches.reverse().forEach(match => {
      const before = result.slice(0, match.start);
      const after = result.slice(match.end);
      result = before + `<span class="${emitter.classPrefix}${match.scope}">${escapeHTML(match.text)}</span>` + after;
    });

    emitter.buffer = result;
    return { relevance };
  }

  Object.keys(languages).forEach(name => {
    if (name !== 'plaintext') {
      hljs.registerLanguage(name, () => languages[name]);
    }
  });

  window.hljs = hljs;
})(window);