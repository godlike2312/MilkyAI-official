/*! highlight.js v11.9.0 | BSD3 License | git.io/hljslicense */
(function(window) {
  const hljs = {
    highlightElement: function(block) {
      try {
        if (block && block.textContent) {
          block.classList.add('hljs');
          const code = block.textContent;
          const language = detectLanguage(block);
          const result = hljs.highlight(code, { language: language || 'plaintext', ignoreIllegals: true });
          block.innerHTML = result.value;
          block.classList.add(`language-${result.language}`);
        }
      } catch (e) {
        console.error('Error in syntax highlighting:', e);
      }
    },
    highlight: function(code, options) {
      const language = options.language || 'plaintext';
      const grammar = languages[language] || languages['plaintext'];
      const emitter = new HTMLRenderer({ classPrefix: 'hljs-' });
      const result = compileLanguage(code, grammar, emitter);
      return {
        value: emitter.toHTML(),
        language: language,
        relevance: result.relevance
      };
    },
    highlightAuto: function(code, languageSubset) {
      const languagesToTry = languageSubset || Object.keys(languages);
      let bestResult = { relevance: 0, value: escapeHTML(code), language: 'plaintext' };
      for (const lang of languagesToTry) {
        try {
          const result = hljs.highlight(code, { language: lang });
          if (result.relevance > bestResult.relevance) {
            bestResult = result;
          }
        } catch (e) {}
      }
      return bestResult;
    },
    highlightAll: function() {
      document.querySelectorAll('pre code').forEach(hljs.highlightElement);
    },
    registerLanguage: function(name, language) {
      try {
        languages[name] = language(hljs);
        languages[name].name = name;
      } catch (e) {
        console.error(`Failed to register language '${name}':`, e);
      }
    },
    listLanguages: function() {
      return Object.keys(languages);
    },
    getLanguage: function(name) {
      return languages[name.toLowerCase()];
    }
  };

  const languages = {
    plaintext: { name: 'Plain text', contains: [] },
    javascript: {
      name: 'JavaScript',
      keywords: 'break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield async await',
      contains: [
        { scope: 'string', begin: '"', end: '"', contains: [{ begin: '\\\\.' }] },
        { scope: 'string', begin: "'", end: "'", contains: [{ begin: '\\\\.' }] },
        { scope: 'string', begin: '`', end: '`', contains: [{ begin: '\\${', end: '}' }] },
        { scope: 'comment', begin: '//', end: '$' },
        { scope: 'comment', begin: '/\\*', end: '\\*/' },
        { scope: 'number', begin: '\\b(0[xX][0-9a-fA-F]+|0[bB][01]+|(\\d*\\.?\\d+([eE][-+]?\\d+)?))\\b' },
        { scope: 'keyword', begin: function() { return '\\b(' + this.keywords.split(' ').join('|') + ')\\b'; }.bind(this) },
        { scope: 'function', begin: '\\bfunction\\s+([a-zA-Z_]\\w*)', end: '\\s*(?=[({])', contains: [{ scope: 'title', begin: '([a-zA-Z_]\\w*)', end: '(?=\\s*(?:\\(|{))' }] },
        { scope: 'operator', begin: '[+\\-*/%=&|!><?:]' }
      ]
    },
    python: {
      name: 'Python',
      keywords: 'and as assert break class continue def del elif else except exec finally for from global if import in is lambda nonlocal not or pass print raise return try while with yield True False None',
      contains: [
        { scope: 'string', begin: '"', end: '"', contains: [{ begin: '\\\\.' }] },
        { scope: 'string', begin: "'", end: "'", contains: [{ begin: '\\\\.' }] },
        { scope: 'string', begin: '"""', end: '"""' },
        { scope: 'comment', begin: '#', end: '$' },
        { scope: 'number', begin: '\\b(0[xX][0-9a-fA-F]+|0[bB][01]+|(\\d*\\.?\\d+([eE][-+]?\\d+)?))\\b' },
        { scope: 'keyword', begin: function() { return '\\b(' + this.keywords.split(' ').join('|') + ')\\b'; }.bind(this) },
        { scope: 'function', begin: '\\bdef\\s+([a-zA-Z_]\\w*)', end: '(?=\\():', contains: [{ scope: 'title', begin: '([a-zA-Z_]\\w*)', end: '(?=\\():' }] }
      ]
    },
    css: {
      name: 'CSS',
      contains: [
        { scope: 'selector-tag', begin: '\\b[a-zA-Z][a-zA-Z0-9-]*\\b' },
        { scope: 'selector-class', begin: '\\.[a-zA-Z][a-zA-Z0-9-]*\\b' },
        { scope: 'selector-id', begin: '#[a-zA-Z][a-zA-Z0-9-]*\\b' },
        { scope: 'property', begin: '[a-zA-Z][a-zA-Z0-9-]*\\s*(?=:)' },
        { scope: 'string', begin: '"', end: '"', contains: [{ begin: '\\\\.' }] },
        { scope: 'string', begin: "'", end: "'", contains: [{ begin: '\\\\.' }] },
        { scope: 'comment', begin: '/\\*', end: '\\*/' },
        { scope: 'number', begin: '\\b\\d+(\\.\\d+)?\\b' },
        { scope: 'unit', begin: '\\b(px|rem|em|vw|vh|%)\\b' }
      ]
    }
  };

  function escapeHTML(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
  }

  function detectLanguage(block) {
    const className = block.className || '';
    const match = /\blang(?:uage)?-([\w-]+)\b/i.exec(className);
    return match ? match[1] : null;
  }

  class HTMLRenderer {
    constructor(options) {
      this.buffer = '';
      this.classPrefix = options.classPrefix || '';
      this.stack = [];
    }
    addText(text) {
      this.buffer += escapeHTML(text);
    }
    openNode(scope) {
      if (scope) {
        const className = this.classPrefix + (scope.includes('.') ? scope.replace(/\./g, '_') : scope);
        this.buffer += `<span class="${className}">`;
        this.stack.push(scope);
      }
    }
    closeNode() {
      if (this.stack.length) {
        this.buffer += '</span>';
        this.stack.pop();
      }
    }
    toHTML() {
      while (this.stack.length) this.closeNode();
      return this.buffer;
    }
  }

  function compileLanguage(code, grammar, emitter) {
    let relevance = 0;
    let index = 0;
    let buffer = '';

    function processToken(token, scope) {
      emitter.openNode(scope);
      emitter.addText(token);
      emitter.closeNode();
      relevance += scope ? 1 : 0;
    }

    const contains = grammar.contains || [];
    const regexes = contains.map(rule => ({
      scope: rule.scope,
      regex: new RegExp(rule.begin + '|' + (rule.end || '$'), 'g')
    }));

    while (index < code.length) {
      let match = null;
      let minIndex = code.length;
      let matchedScope = null;

      for (const rule of regexes) {
        rule.regex.lastIndex = index;
        const m = rule.regex.exec(code);
        if (m && m.index < minIndex && m.index === index) {
          match = m;
          minIndex = m.index;
          matchedScope = rule.scope;
        }
      }

      if (match) {
        processToken(match[0], matchedScope);
        index += match[0].length;
      } else {
        buffer += code[index];
        index++;
      }
    }

    if (buffer) emitter.addText(buffer);

    return { relevance };
  }

  Object.keys(languages).forEach(name => {
    if (name !== 'plaintext') {
      hljs.registerLanguage(name, () => languages[name]);
    }
  });

  window.hljs = hljs;
})(window);